/*
Copyright [2014] - [2021] The Last.Backend authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package genengine

import (
	"github.com/lastbackend/engine/protoc-gen-engine/descriptor"

	"bytes"
	"fmt"
	"strings"
	"text/template"
)

type tplOptions struct {
	*descriptor.File
	Imports          []descriptor.GoPackage
	Plugins          map[string]map[string]*Plugin
	Clients          map[string]*Client
	ProtocVersion    string
	GeneratorVersion string
}

type Plugin struct {
	Prefix string
	Plugin string
	Pkg    string
}

type Client struct {
	Service string
	Pkg     string
}

type contentParams struct {
	Plugins  map[string]map[string]*Plugin
	Clients  map[string]*Client
	Services []*descriptor.Service
}

func applyTemplate(to tplOptions) (string, error) {
	w := bytes.NewBuffer(nil)

	if err := headerTemplate.Execute(w, to); err != nil {
		return "", err
	}

	var targetServices = make([]*descriptor.Service, 0)
	for _, msg := range to.Messages {
		msgName := camel(*msg.Name)
		msg.Name = &msgName
	}

	for _, svc := range to.Services {
		svcName := camel(*svc.Name)
		svc.Name = &svcName
		targetServices = append(targetServices, svc)
	}

	tp := contentParams{
		Plugins:  to.Plugins,
		Clients:  to.Clients,
		Services: targetServices,
	}

	if err := contentTemplate.Execute(w, tp); err != nil {
		return "", err
	}

	return w.String(), nil
}

func TagValue(str string) string {
	return fmt.Sprintf("`name:\"%s\"`", str)
}

var (
	headerTemplate = template.Must(template.New("header").Parse(`
// Code generated by protoc-gen-engine. DO NOT EDIT.
// source: {{ .GetName }}
// versions:
// - protoc            {{ .ProtocVersion }}
// - protoc-gen-engine {{ .GeneratorVersion }}

package {{ .GoPkg.Name }}

import (
	{{range $i := .Imports}}{{if $i.Standard}}{{$i | printf "%s\n"}}{{end}}{{end}}

	{{range $i := .Imports}}{{if not $i.Standard}}{{$i | printf "%s\n"}}{{end}}{{end}}

	"github.com/lastbackend/engine/client/grpc"
)

// Suppress "imported and not used" errors
var _ context.Context
var _ logger.Logger
var _ server.Server
`))

	funcMap = template.FuncMap{
		"ToUpper":      strings.ToUpper,
		"ToLower":      strings.ToLower,
		"ToCapitalize": strings.Title,
		"ToTagValue":   TagValue,
	}

	_ = template.Must(contentTemplate.New("services-content").Parse(`
type Service interface {
	Logger() logger.Logger
	Meta() engine.Meta
	CLI() engine.CLI
	Run(ctx context.Context) error

	SetServer(srv interface{})
	SetService(svc interface{})
	SetConfig(cfg interface{})

	{{- range $type, $plugins := .Plugins}}
		{{- range $name, $plugin := $plugins}} 
			Set{{$name | ToCapitalize}}({{$plugin.Prefix | ToLower}} interface{})
		{{end}}
	{{end}}
}

{{range $svc := .Services}}
type {{$svc.GetName}}RPC struct {
	Grpc grpc.RpcClient
	{{range $key, $value := $.Clients -}}
		{{$value.Service | ToCapitalize}} {{$key}}.{{$value.Service | ToCapitalize}}RpcClient
	{{end}}
}
{{end}}

func NewService(name string) Service {
	return &service{
		engine: engine.NewService(name),
		srv:     make([]interface{}, 0),
		svc:     make([]interface{}, 0),
		{{range $svc := .Services -}}
		rpc{{$svc.GetName}}:    new({{$svc.GetName}}RPC),
		{{end}}
		{{- range $type, $plugins := .Plugins}}
			{{- range $name, $plugin := $plugins}} 
				{{$plugin.Prefix | ToLower}}: {{$plugin.Plugin}}.NewPlugin,
			{{end}}
		{{end}}
	}
}

type service struct {
	engine engine.Service

	{{range $svc := .Services -}}
	rpc{{$svc.GetName}} *{{$svc.GetName}}RPC
	{{end}}
	
	srv []interface{}
	svc []interface{}
	cfg interface{}

	{{- range $type, $plugins := .Plugins}}
		{{- range $name, $plugin := $plugins}} 
			{{$plugin.Prefix | ToLower}} interface{}
		{{end}}
	{{end}}
}

func (s *service) Meta() engine.Meta {
	return s.engine.Meta()
}

func (s *service) CLI() engine.CLI {
	return s.engine.CLI()
}

func (s *service) Logger() logger.Logger {
	return s.engine.Logger()
}

func (s *service) SetServer(srv interface{}) {
	s.srv = append(s.srv, srv)
}

func (s *service) SetService(svc interface{}) {
	s.svc = append(s.svc, svc)
}

func (s *service) SetConfig(cfg interface{}) {
	s.cfg = cfg
}

{{- range $type, $plugins := .Plugins}}
	{{- range $name, $plugin := $plugins}} 
		func (s *service) Set{{$name | ToCapitalize}}({{$plugin.Prefix | ToLower}} interface{}) {
			s.{{$plugin.Prefix | ToLower}} = {{$plugin.Prefix | ToLower}}
		}
	{{end}}
{{end}}

func (s *service) Run(ctx context.Context) error {
	provide := make([]interface{}, 0)
	provide = append(provide,
		fx.Annotate(
			func() engine.Service {
				return s.engine
			},
			fx.ResultTags({{"engine" | ToTagValue}}),
		),
		{{- range $type, $plugins := .Plugins}}
			{{- range $name, $plugin := $plugins}}
				fx.Annotate(
					func() *{{$plugin.Plugin}}.Options {
						return &{{$plugin.Plugin}}.Options{
							Name: "{{$plugin.Prefix | ToLower}}",
						}
					},
					fx.ResultTags({{$plugin.Prefix | ToLower | ToTagValue}}),
				),
			{{end}}
		{{end}}
		func() Service {
			return s
		},
		{{range $svc := .Services}}
		func() *{{$svc.GetName}}RPC {
			return s.rpc{{$svc.GetName}}
		},
		{{end}}
	)
	provide = append(provide, s.svc...)
	provide = append(provide, s.srv...)
	provide = append(provide,
		{{- range $type, $plugins := .Plugins}}
			{{- range $name, $plugin := $plugins}}
				fx.Annotate(
					s.{{$plugin.Prefix | ToLower}},
					fx.ParamTags({{"engine" | ToTagValue}}, {{$plugin.Prefix | ToLower | ToTagValue}}),
				),
			{{end}}
		{{end}}
	)

	app := fx.New(
		fx.Options(
			fx.Supply(s.cfg),
			fx.Provide(provide...),
			{{- range $svc := .Services}}			
				fx.Invoke(s.register{{$svc.GetName}}Client),
				fx.Invoke(s.register{{$svc.GetName}}Server),
			{{end}}
			fx.Invoke(s.runService),
		),
		fx.NopLogger,
	)

	go app.Run()

	if app.Err() != nil {
		app.Stop(ctx)
		return app.Err()
	}

	<-app.Done()

	return nil
}

{{range $svc := .Services}}
func (s *service) register{{$svc.GetName}}Client() error {

	// Register clients
	
	s.rpc{{$svc.GetName}}.Grpc = grpc.NewClient(s.engine, &grpc.ClientOptions{Name: "client-{{$svc.GetName | ToLower}}-grpc"})

	if err := s.engine.ClientRegister(s.rpc{{$svc.GetName}}.Grpc); err != nil {
		return err
	}

	{{range $key, $value := $.Clients}}
		s.rpc{{$svc.GetName}}.{{$value.Service | ToCapitalize}} = {{$value.Service | ToLower}}.New{{$value.Service | ToCapitalize}}RpcClient("{{$value.Service | ToLower}}", s.rpc{{$svc.GetName}}.Grpc.Client())
	{{end}}

	return nil
}

func (s *service) register{{$svc.GetName}}Server(srv {{$svc.GetName}}RpcServer) error {

	// Register servers

	type {{$svc.GetName}}GrpcRpcServer struct {
			{{$svc.GetName}}Server
	}

	h := &{{$svc.GetName | ToLower}}GrpcRpcServer{srv.({{$svc.GetName}}RpcServer)}
	grpcServer := server.NewServer(s.engine, &server.ServerOptions{Name: "server-{{$svc.GetName | ToLower}}-grpc"})
	if err := grpcServer.Register(&{{$svc.GetName}}_ServiceDesc, &{{$svc.GetName}}GrpcRpcServer{h}); err != nil {
		return err
	}

	if err := s.engine.ServerRegister(grpcServer); err != nil {
		return err
	}

	return nil
}
{{end}}

func (s *service) runService(lc fx.Lifecycle) error {
	lc.Append(fx.Hook{
		OnStart: func(ctx context.Context) error {
			return s.engine.Run()
		},
		OnStop: func(ctx context.Context) error {
			return nil
		},
	})
	return nil
}


`))

	_ = template.Must(contentTemplate.New("server-content").Parse(`
{{range $svc := .Services}}
	// Server API for Api service
	type {{$svc.GetName}}RpcServer interface {
		{{range $m := $svc.Methods}}
    {{if and (not $m.GetServerStreaming) (not $m.GetClientStreaming)}}
			{{$m.GetName}}(ctx context.Context, req *{{$m.RequestType.GoName}}) (*{{$m.ResponseType.GoName}}, error)
    {{else}}{{if not $m.GetClientStreaming}}
			{{$m.GetName}}(req *{{$m.RequestType.GoName}}, stream {{$svc.GetName}}_{{$m.GetName}}Server) error
    {{else}}
			{{$m.GetName}}(stream {{$svc.GetName}}_{{$m.GetName}}Server) error
    {{end}}{{end}}
	{{end}}
	}
{{end}}

{{range $svc := .Services}}
	type {{$svc.GetName | ToLower}}GrpcRpcServer struct {
		{{$svc.GetName}}RpcServer
	}

	{{range $m := $svc.Methods}}
    {{if and (not $m.GetServerStreaming) (not $m.GetClientStreaming)}}
  		func (h *{{$svc.GetName | ToLower}}GrpcRpcServer) {{$m.GetName}}(ctx context.Context, req *{{$m.RequestType.GoName}}) (*{{$m.ResponseType.GoName}}, error) {
				return h.{{$svc.GetName}}RpcServer.{{$m.GetName}}(ctx, req)
			}
    {{else}}{{if not $m.GetClientStreaming}}
			func (h *{{$svc.GetName | ToLower}}GrpcRpcServer) {{$m.GetName}}(req *{{$m.RequestType.GoName}}, stream {{$svc.GetName}}_{{$m.GetName}}Server) error {
				return h.{{$svc.GetName}}RpcServer.{{$m.GetName}}(req, stream)
			}
    {{else}}
			func (h *{{$svc.GetName | ToLower}}GrpcRpcServer) {{$m.GetName}}(stream {{$svc.GetName}}_{{$m.GetName}}Server) error {
				return h.{{$svc.GetName}}RpcServer.{{$m.GetName}}(stream)
			}
    {{end}}{{end}}
	{{end}}
	func ({{$svc.GetName | ToLower}}GrpcRpcServer) mustEmbedUnimplemented{{$svc.GetName}}Server() {}
{{end}}
`))

	_ = template.Must(contentTemplate.New("client-content").Parse(`
{{range $svc := .Services}}
	// Client gRPC API for {{$svc.GetName}} service
	func New{{$svc.GetName}}RpcClient(service string, c grpc.Client) {{$svc.GetName}}RpcClient {
		return &{{$svc.GetName | ToLower}}GrpcRpcClient{service, c}
	}

	// Client gRPC API for {{$svc.GetName}} service
	type {{$svc.GetName}}RpcClient interface {
		{{range $m := $svc.Methods}}
			{{if and (not $m.GetServerStreaming) (not $m.GetClientStreaming)}}
				{{$m.GetName}}(ctx context.Context, req *{{$m.RequestType.GoName}}, opts ...grpc.CallOption) (*{{$m.ResponseType.GoName}}, error)
			{{else}}
				{{if not $m.GetClientStreaming}}
					{{$m.GetName}}(ctx context.Context, req *{{$m.RequestType.GoName}}, opts ...grpc.CallOption) ({{$svc.GetName}}_{{$m.GetName}}Service, error)
				{{else}}
					{{$m.GetName}}(ctx context.Context, opts ...grpc.CallOption) ({{$svc.GetName}}_{{$m.GetName}}Service, error)
				{{end}}
			{{end}}
		{{end}}
	}
{{end}}

{{range $svc := .Services}}
	type {{$svc.GetName | ToLower}}GrpcRpcClient struct {
		service string
		cli     grpc.Client
	}

	{{range $m := $svc.Methods}}
		{{if and (not $m.GetServerStreaming) (not $m.GetClientStreaming)}}
			func (c *{{$svc.GetName | ToLower}}GrpcRpcClient) {{$m.GetName}}(ctx context.Context, req *{{$m.RequestType.GoName}}, opts ...grpc.CallOption) (*{{$m.ResponseType.GoName}}, error) {
				resp := new({{$m.ResponseType.GoName}})
				if err := c.cli.Call(ctx, c.service, {{$svc.GetName}}_{{$m.GetName}}Method, req, resp, opts...); err != nil {
					return nil, err
				}
				return resp, nil
			}
		{{else}}
			{{if not $m.GetClientStreaming}}
				func (c *{{$svc.GetName | ToLower}}GrpcRpcClient) {{$m.GetName}}(ctx context.Context, req *{{$m.RequestType.GoName}}, opts ...grpc.CallOption) ({{$svc.GetName}}_{{$m.GetName}}Service, error) {
					stream, err := c.cli.Stream(ctx, c.service, {{$svc.GetName}}_{{$m.GetName}}Method, req, opts...)
					if err != nil {
						return nil, err
					}
					if err := stream.SendMsg(req); err != nil {
						return nil, err
					}
					return &{{$svc.GetName | ToLower}}{{$m.GetName}}Service{stream}, nil
				}
			{{else}}
				func (c *{{$svc.GetName | ToLower}}GrpcRpcClient) {{$m.GetName}}(ctx context.Context,  opts ...grpc.CallOption) ({{$svc.GetName}}_{{$m.GetName}}Service, error) {
					stream, err := c.cli.Stream(ctx, c.service, {{$svc.GetName}}_{{$m.GetName}}Method, nil, opts...)
					if err != nil {
						return nil, err
					}
					return &{{$svc.GetName | ToLower}}{{$m.GetName}}Service{stream}, nil
				}
			{{end}}

			type {{$svc.GetName}}_{{$m.GetName}}Service interface {
				SendMsg(interface{}) error
				RecvMsg(interface{}) error
				Close() error
				Recv() (*{{$m.ResponseType.GoName}}, error)
				{{if $m.GetClientStreaming}}Send(*{{$m.RequestType.GoName}}) error{{end}}
			}

			type {{$svc.GetName | ToLower}}{{$m.GetName}}Service struct {
				stream grpc.Stream
			}

			func (x *{{$svc.GetName | ToLower}}{{$m.GetName}}Service) Close() error {
				return x.stream.CloseSend()
			}

			func (x *{{$svc.GetName | ToLower}}{{$m.GetName}}Service) SendMsg(m interface{}) error {
				return x.stream.SendMsg(m)
			}

			func (x *{{$svc.GetName | ToLower}}{{$m.GetName}}Service) RecvMsg(m interface{}) error {
				return x.stream.RecvMsg(m)
			}

			func (x *{{$svc.GetName | ToLower}}{{$m.GetName}}Service) Recv() (*{{$m.ResponseType.GoName}}, error) {
				m := new({{$m.ResponseType.GoName}})
				err := x.stream.RecvMsg(m)
				if err != nil {
					return nil, err
				}
				return m, nil
			}

			{{if $m.GetClientStreaming}}
			func (x *{{$svc.GetName | ToLower}}{{$m.GetName}}Service) Send(m *{{$m.RequestType.GoName}}) error {
				return x.stream.SendMsg(m)
			}
			{{end}}

		{{end}}
	{{end}}

	func ({{$svc.GetName | ToLower}}GrpcRpcClient) mustEmbedUnimplemented{{$svc.GetName}}Client() {}
{{end}}

{{range $svc := .Services}}
	// Client methods for {{$svc.GetName}} service
	const (
		{{range $m := $svc.Methods}}
			{{$svc.GetName}}_{{$m.GetName}}Method = "/{{$svc.GetName | ToLower}}.{{$svc.GetName}}/{{$m.GetName}}"
		{{end}}
	)
{{end}}
`))

	contentTemplate = template.Must(template.New("content").Funcs(funcMap).Parse(`
{{template "services-content" .}}
{{template "server-content" .}}
{{template "client-content" .}}
`))
)
