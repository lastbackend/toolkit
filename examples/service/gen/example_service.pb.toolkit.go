// Code generated by protoc-gen-toolkit. DO NOT EDIT.
// source: github.com/lastbackend/toolkit/examples/service/apis/example.proto

package servicepb

import (
	"context"
	"encoding/json"
	"io"
	"net/http"
	"os"
	"os/signal"
	"syscall"

	toolkit "github.com/lastbackend/toolkit"
	"github.com/lastbackend/toolkit/examples/service/gen/ptypes"
	grpc "github.com/lastbackend/toolkit/pkg/client/grpc"
	logger "github.com/lastbackend/toolkit/pkg/logger"
	router "github.com/lastbackend/toolkit/pkg/router"
	errors "github.com/lastbackend/toolkit/pkg/router/errors"
	ws "github.com/lastbackend/toolkit/pkg/router/ws"
	server "github.com/lastbackend/toolkit/pkg/server"
	"github.com/lastbackend/toolkit/plugin/postgres_gorm"
	"github.com/lastbackend/toolkit/plugin/redis"
	fx "go.uber.org/fx"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the toolkit package it is being compiled against and
// suppress "imported and not used" errors
var _ context.Context
var _ logger.Logger
var _ emptypb.Empty
var _ server.Server
var _ grpc.Client
var _ http.Handler
var _ errors.Err
var _ io.Reader
var _ json.Marshaler
var _ ws.Client
var _ server.Server

type middleware map[string][]func(h http.Handler) http.Handler

func (m middleware) getMiddleware(name string) router.Middleware {
	middleware := router.Middleware{}
	if m[name] != nil {
		for _, mdw := range m[name] {
			middleware.Add(mdw)
		}
	}
	return middleware
}

var middlewares = make(middleware, 0)

type Service interface {
	Logger() logger.Logger
	Meta() toolkit.Meta
	CLI() toolkit.CLI
	Client() grpc.Client
	Router() router.Server
	Run(ctx context.Context) error

	SetConfig(cfg interface{})
	SetServer(srv interface{})

	AddPackage(pkg interface{})
	AddMiddleware(mdw interface{})
	Invoke(fn interface{})
}

type RPC struct {
	Grpc grpc.Client
}

func NewService(name string) Service {
	return &service{
		toolkit: toolkit.NewService(name),
		srv:     make([]interface{}, 0),
		pkg:     make([]interface{}, 0),
		inv:     make([]interface{}, 0),
		rpc:     new(RPC),
	}
}

type service struct {
	toolkit toolkit.Service
	rpc     *RPC
	srv     []interface{}
	pkg     []interface{}
	inv     []interface{}
	cfg     interface{}
	mdw     interface{}
}

func (s *service) Meta() toolkit.Meta {
	return s.toolkit.Meta()
}

func (s *service) CLI() toolkit.CLI {
	return s.toolkit.CLI()
}

func (s *service) Logger() logger.Logger {
	return s.toolkit.Logger()
}

func (s *service) Router() router.Server {
	return s.toolkit.Router()
}

func (s *service) Client() grpc.Client {
	return s.toolkit.Client()
}

func (s *service) SetConfig(cfg interface{}) {
	s.cfg = cfg
}

func (s *service) SetServer(srv interface{}) {
	if srv == nil {
		return
	}
	s.srv = append(s.srv, srv)
}

func (s *service) AddPackage(pkg interface{}) {
	if pkg == nil {
		return
	}
	s.pkg = append(s.pkg, pkg)
}

func (s *service) AddMiddleware(mdw interface{}) {
	s.mdw = mdw
}

func (s *service) Invoke(fn interface{}) {
	if fn == nil {
		return
	}
	s.inv = append(s.inv, fn)
}

type PgsqlPlugin interface {
	postgres_gorm.Plugin
}

type RedisPlugin interface {
	redis.Plugin
}

func (s *service) Run(ctx context.Context) error {

	plugin_0 := postgres_gorm.NewPlugin(s.toolkit, &postgres_gorm.Options{Name: "pgsql"})

	plugin_1 := redis.NewPlugin(s.toolkit, &redis.Options{Name: "redis"})

	provide := make([]interface{}, 0)
	provide = append(provide,
		fx.Annotate(
			func() toolkit.Service {
				return s.toolkit
			},
		),
		func() Service {
			return s
		},
		func() *RPC {
			return s.rpc
		},
		fx.Annotate(
			func() PgsqlPlugin {
				return plugin_0
			},
		),

		fx.Annotate(
			func() RedisPlugin {
				return plugin_1
			},
		),
	)

	provide = append(provide, s.pkg...)
	provide = append(provide, s.srv...)

	opts := make([]fx.Option, 0)

	if s.cfg != nil {
		opts = append(opts, fx.Supply(s.cfg))
	}

	opts = append(opts, fx.Provide(provide...))
	opts = append(opts, fx.Invoke(s.registerClients))
	opts = append(opts, fx.Invoke(s.registerExampleServer))
	opts = append(opts, fx.Invoke(s.inv...))
	if s.mdw != nil {
		opts = append(opts, fx.Invoke(s.mdw))
	}
	opts = append(opts, fx.Invoke(s.registerRouter))
	opts = append(opts, fx.Invoke(s.runService))

	app := fx.New(
		fx.Options(opts...),
		fx.NopLogger,
	)

	if err := app.Start(ctx); err != nil {
		return err
	}

	signalCh := make(chan os.Signal, 1)
	signal.Notify(signalCh, shutdownSignals...)

	select {
	// wait on kill signal
	case <-signalCh:
	// wait on context cancel
	case <-ctx.Done():
	}

	return app.Stop(ctx)
}

func (s *service) registerClients() error {

	// Register clients

	s.rpc.Grpc = s.toolkit.Client()

	return nil
}

func (s *service) registerExampleServer(srv ExampleRpcServer) error {

	// Register servers

	type ExampleGrpcRpcServer struct {
		ExampleServer
	}

	h := &exampleGrpcRpcServer{srv.(ExampleRpcServer)}

	grpcexampleServer := server.NewServer(s.toolkit, &server.ServerOptions{Name: "grpc"})

	if err := grpcexampleServer.Register(&Example_ServiceDesc, &ExampleGrpcRpcServer{h}); err != nil {
		return err
	}

	if err := s.toolkit.ServerRegister(grpcexampleServer); err != nil {
		return err
	}

	return nil
}

func (s *service) registerRouter() {

}

func registerMiddleware(name string, mdw ...func(h http.Handler) http.Handler) {
	if middlewares[name] == nil {
		middlewares[name] = make([]func(h http.Handler) http.Handler, 0)
	}
	for _, h := range mdw {
		middlewares[name] = append(middlewares[name], h)
	}
}

func HelloWorldMiddlewareAdd(mdw ...func(h http.Handler) http.Handler) {
	registerMiddleware("HelloWorld", mdw...)
}

func (s *service) runService(lc fx.Lifecycle) error {
	lc.Append(fx.Hook{
		OnStart: func(ctx context.Context) error {
			return s.toolkit.Start(ctx)
		},
		OnStop: func(ctx context.Context) error {
			return s.toolkit.Stop(ctx)
		},
	})
	return nil
}

var shutdownSignals = []os.Signal{
	syscall.SIGTERM,
	syscall.SIGINT,
	syscall.SIGQUIT,
	syscall.SIGKILL,
}

// Server API for Api service
type ExampleRpcServer interface {
	HelloWorld(ctx context.Context, req *typespb.HelloWorldRequest) (*typespb.HelloWorldResponse, error)
}

type exampleGrpcRpcServer struct {
	ExampleRpcServer
}

func (h *exampleGrpcRpcServer) HelloWorld(ctx context.Context, req *typespb.HelloWorldRequest) (*typespb.HelloWorldResponse, error) {
	return h.ExampleRpcServer.HelloWorld(ctx, req)
}

func (exampleGrpcRpcServer) mustEmbedUnimplementedExampleServer() {}
